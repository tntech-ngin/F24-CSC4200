var suggestions=document.getElementById("suggestions"),search=document.getElementById("search");search!==null&&document.addEventListener("keydown",inputFocus);function inputFocus(e){e.ctrlKey&&e.key==="/"&&(e.preventDefault(),search.focus()),e.key==="Escape"&&(search.blur(),suggestions.classList.add("d-none"))}document.addEventListener("click",function(e){var t=suggestions.contains(e.target);t||suggestions.classList.add("d-none")}),document.addEventListener("keydown",suggestionFocus);function suggestionFocus(e){const s=suggestions.classList.contains("d-none");if(s)return;const t=[...suggestions.querySelectorAll("a")];if(t.length===0)return;const n=t.indexOf(document.activeElement);if(e.key==="ArrowUp"){e.preventDefault();const s=n>0?n-1:0;t[s].focus()}else if(e.key==="ArrowDown"){e.preventDefault();const s=n+1<t.length?n+1:n;t[s].focus()}}(function(){var e=new FlexSearch.Document({tokenize:"forward",cache:100,document:{id:"id",store:["href","title","description"],index:["title","description","content"]}});e.add({id:0,href:"/docs/prologue/schedule/",title:"Schedule",description:`This is a tentative schedule and will change.
Grading details #Assessment Type Weightage Additional Information Homework 20% Exams (3 exams) 35% Programming Assignments 35% One late submission allowed. 50% deducted for other late submissions. Class Participation 10% Class Schedule #Introduction, Social Contract, Expectations - Link to Mural Slides Books - Peterson \u0026amp; Davie, Computer Networks - a systems approach. Labs - Every Friday, in class Week 1- Aug 26-30: #Reading assignment for week 1 - Introduction, Chapter 1.`,content:`This is a tentative schedule and will change.
Grading details #Assessment Type Weightage Additional Information Homework 20% Exams (3 exams) 35% Programming Assignments 35% One late submission allowed. 50% deducted for other late submissions. Class Participation 10% Class Schedule #Introduction, Social Contract, Expectations - Link to Mural Slides Books - Peterson \u0026amp; Davie, Computer Networks - a systems approach. Labs - Every Friday, in class Week 1- Aug 26-30: #Reading assignment for week 1 - Introduction, Chapter 1.2 - 1.5 Introduction - Terminologies, Circuit vs Packet Switching, Layers, Architectures vs Protocols Slides Network Performance, Bandwidth/Delay, Jitter Slides Lab (Setting up Google Cloud VMs) Week 2 - Sept 4-6: #No class on Sept 2 Reading assignment - Chapter 2-2.5
Links, Encoding, Frames, Point to point links, Byte Stuffing, Error detection Slides Reliable Delivery, Stop-n-wait, sliding window Slides Lab: Examples and Socket Programming Slides Week 3 - Sept 9-13: #Reading assignment - Chapter 2.6-2.7
Links, Encoding, Frames, Point to point links, Byte Stuffing, Error detection Slides Reliable Delivery, Stop-n-wait, sliding window Slides Lab: Examples and Socket Programming Slides Week 4 - Sept 16-20: #Ethernet, Wifi, CSMA-CA/CD, Transmitter algorithm, Collision avoidance, Slides Link Layer Recap Slides Lab Week 5 - Sept 23-27: #Reading assignment - Chapter 3-3.2.5, Basic IP
Switching Slides Lab Week 6 - Sept 30-Oct 04: #Reading assignment Chapter - 3.2.6-3.2.9 Spanning Tree, Loop detection Slides Addressing Slides Lab Week 7 - Oct 07-11: #ARP, DHCP Slides NAT, ICMP, Routing vs Switching Slides Lab Week 8 - Oct 14-16: #No class on Oct 18 Reading assignment - Chapter 3.3
Routing Slides Routing, Issues with Scaling Slides BGP Slides Week 9 - Oct 21 - Oct 25 #Reading assignment - Chapter 4.1
BGP Slides Lab Week of Oct 28 - Nov 01 #Reading assignment - 5.1, 5.2.1-5.2.5
MPLS, End to End communication UDP, TCP Slides [UDP] TCP Flow Control, Three way handshake Slides Lab Week of Nov 13 - Nov 15 #Reading assignment - Chapter 6.3
TCP Congestion control, Congestion avoidance Slides HTTP Slides DNS, Email Slides Week of Nov 18 - Nov 22 ( Exam 2) #Reading assignment - Chapter 9.1
Network Security, Symmetric Key Slides Network Security, Asymmetric Key Slides Week of Nov 25 - Nov 29 #No class on 27-29
Nov 25 - Demo Week of Dec 2 - Dec 4 #Review Dec 09 #Final `}),e.add({id:1,href:"/docs/prologue/pa-packet-handling/",title:"Program 1: Network Packet Handling",description:"Implement a client-server application to handle custom network packets with Python.",content:`This is an INDIVIDUAL Assignment (Do not collaborate) #Instructions #Please read the entire instructions and the skeleton code provided for the server and the client before you start coding.
Setup #Create two separate Python files for the server and client, named server.py and client.py, respectively. Copy and paste the provided skeleton code into the respective files. Implementation #Server: Complete the server code by implementing the unpack_packet function. The server should accept connections, receive custom packets from clients, unpack the packets, and echo back the packet fields. Client: Complete the client code by implementing the create_packet and handle_packet functions. The client should connect to the server, create packets based on user input and command-line arguments, and display the server\u0026rsquo;s echoed responses. Testing and Submission #Test your server and client by running them in separate VMs. Ensure that they can handle different types of payloads based on the header\u0026rsquo;s service type. Error Handling: Perform error handling, add comments for clarity, and optimize the code as needed. Submit your completed server.py and client.py files for evaluation through the submission platform. Server Skeleton Code #import socket import struct def unpack_packet(conn, header_format): # TODO: Implement header unpacking based on received bytes # TODO: Create a string from the header fields # return the string - this will be the payload return packet_header_as_string if __name__ == '__main__': host = 'localhost' port = 12345 # Fixed length header -\u0026gt; Version (1 byte), Header Length (1 byte), Service Type (1 byte), Payload Length (2 bytes) header_format = '' # TODO: Specify the header format using \u0026quot;struct\u0026quot; with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: s.bind((host, port)) s.listen() conn, addr = s.accept() with conn: print(f\u0026quot;Connected by: {addr}\u0026quot;) while True: try: # TODO: Receive and unpack packet using the unpack_packet function payload_string = unpack_packet(conn, header_format) pass except: print(\u0026quot;Connection closed or an error occurred\u0026quot;) break #TODO: create header #TODO: add payload #TODO: send to client Client Skeleton Code #import argparse import socket import struct def create_packet(version, header_length, service_type, payload): # TODO: Implement packet creation based on parameters # TODO: use the python struct module to create a fixed length header # TODO: Fixed length header -\u0026gt; Version (1 byte), Header Length (1 byte), Service Type (1 byte), Payload Length (2 bytes) # TODO: payload -\u0026gt; variable length # TODO: depending on the service type, handle encoding of the different types of payload. # TODO: service_type 1 = payload is int, service_type 2 = payload is float, service_type 3 = payload is string return packet if __name__ == '__main__': parser = argparse.ArgumentParser(description=\u0026quot;Client for packet creation and sending.\u0026quot;) parser.add_argument('--version', type=int, required=True, help='Packet version') parser.add_argument('--header_length', type=int, required=True, help='Length of the packet header') parser.add_argument('--service_type', type=int, required=True, help='Service type of the payload (1 for int, 2 for float, 3 for string)') parser.add_argument('--payload', type=str, required=True, help='Payload to be packed into the packet') parser.add_argument('--host', type=str, default='localhost', help='Server host') parser.add_argument('--port', type=int, default=12345, help='Server port') args = parser.parse_args() # TODO: Create and send packet using the create_packet function packet = create_packet(args.version, args.header_length, args.service_type, args.payload) #TODO: connect to the server #TODO: send the packet #TODO: recive the packet #TODO: prints header #TODO: prints payload Assignment Rubric #Client Implementation (40 points) #Client Runs (10 points): The client code runs without errors. Client Packs the Packet appropriately (10 points): The client can pack a packet. Type handling: The client code handles different service types properly. The client should be encode different types of payloads (int, float, string) based on the header\u0026rsquo;s service type. Payload Handling (10 points): Prints the header and the new payload returned by the server. The new payload is client header + payload. The header is the header sent by the sever. Server Implementation (40 points) #Server Runs (10 points): The server code runs without errors. Header handling (10 points): The server reads the header first, followed by the payload indicated by the header. Decodes payloads properly: The server code correctly decodes and prints the header and the payload. Constructs and returns new payload =(10 points): The server creates a new payload from the header and payload and sends it back to client. Best coding practices (20 points) #Error Handling (up to 10 points): Exit gracefully after client receives the message, Server never exits. Code Clarity and Comments (up to 10 points): The code is well-commented and easy to understand, making use of meaningful variable and function names. Total Points: /100
`}),e.add({id:2,href:"/docs/prologue/",title:"Prologue",description:"Prologue Doks.",content:""}),e.add({id:3,href:"/docs/prologue/pa-simple-protocol/",title:"Program 2 - Simple Protocol",description:`This is a GROUP Assignment
Objectives
Learn to create network packets.
Learn how packets can be sent over the network.
Familiarize you with the concept of sockets.
Learn packing structures, endianness, unpacking, and interpreting network data.
Learn how to use actual data from a packet.
Use packet capture to visually inspect protocols.
Overview
In this warmup project, you are going to implement a client and a server program that will send a command over the network.`,content:`This is a GROUP Assignment
Objectives
Learn to create network packets.
Learn how packets can be sent over the network.
Familiarize you with the concept of sockets.
Learn packing structures, endianness, unpacking, and interpreting network data.
Learn how to use actual data from a packet.
Use packet capture to visually inspect protocols.
Overview
In this warmup project, you are going to implement a client and a server program that will send a command over the network. The command simply turns on an LED light. However, the LED light speaks a special protocol. All we know about this protocol is the packet format used for turning on the light. Your task is to create this packet and then send it to the server for turning on this light. Server Specifications
The server takes two arguments:
\$ lightserver -p \u0026lt;PORT\u0026gt; -l \u0026lt;LOG FILE LOCATION\u0026gt; 1.PORT - The port server listens on.
2.Log file location - Where you will keep a record of actions.
For example: \$ lightserver -p 30000 -l /tmp/logfile Deliverables (each worth 5 points)
Server must parse two command line arguments, port and log locations.
The server must not exit after receiving a single packet.
Once a client connects, it logs a message in the following format \u0026quot;Received connection from \u0026lt;CLIENT IP, PORT\u0026gt; \u0026quot;
Once it receives a hello message from the client, it logs the connection and sends a hello back to the client.
You can assume the packet format is the following:
+-----------------+--------------------------+-------------------------+ | | | | | | | | |Version(4 bytes) |Message type (4 bytes) |Message Length (4 bytes) | | | | | | | | | +-----------------+--------------------------+-------------------------+ | | | | | Message (Max 8 Bytes) | | | | | +----------------------------------------------------------------------+ It receives the packet header first, followed by the message. Hint: You need two RECV calls.
Check if Version == 17. If not, log an error message VERSION MISMATCH and continue to listen. Do not exit.
If Version == 17, check the message type. If message Type is 1 - the corresponding command is LIGHTON. If message type is 2 - the corresponding command is LIGHTOFF. No other command is supported.
If the server sees a supported command, log \u0026ldquo;EXECUTING SUPPORTED COMMAND: COMMANDNAME\u0026rdquo;, else log \u0026lt;\u0026ldquo;IGNORING UNKNOWN COMMAND: COMMANDNAME\u0026rdquo;.
Send back a \u0026ldquo;SUCCESS\u0026rdquo; message to the client.
It turns on or turns off the LED on your circuit based on the command sent by the client.
Make sure server does not exit on 0 byte messages. Client Specifications
\$ lightclient -s \u0026lt;SERVER-IP\u0026gt; -p \u0026lt;PORT\u0026gt; -l LOGFILE The client takes three arguments:
Server IP - The IP address of the server. PORT - The port the server listens on. Log file location - Where you will keep a record of packets you received. For example: \$ lightclient -s 192.168.2.1 -p 6543 -l LOGFILE Client Requirements (each worth 5 points, item 7 is worth 10 points)
The client must parse three command line arguments, server, port, and logfile. The client should connect to the server on the specified port. Constructs and sends a hello packet to the server. +-----------------+--------------------------+-------------------------+ | | | | | | | | |Version(4 bytes) |Message type (4 bytes) |Message Length (4 bytes) | | | | | | | | | +-----------------+--------------------------+-------------------------+ | | | | | Message (HELLO) | | | | | +----------------------------------------------------------------------+ Receive reply from Server - if version is 17, log \u0026ldquo;VERSION ACCEPTED\u0026rdquo;, else log - \u0026ldquo;VERSION MISMATCH\u0026rdquo; If version is accepted, send a command packet. +-----------------+--------------------------+-------------------------+ | | | | | | | | |Version(4 bytes) |Message type (4 bytes) |Message Length (4 bytes) | | | | | | | | | +-----------------+--------------------------+-------------------------+ | | | | | COMMAND (LIGHTON/LIGHTOFF) | | | | | +----------------------------------------------------------------------+ Receive the server\u0026rsquo;s reply, log the reply, and gracefully shutdown the socket. You can assume the server always replies with a \u0026ldquo;SUCCESS\u0026rdquo; message for this assignment. Use TCPDUMP or Wireshark to capture the interactions, turn the .pcap file in with the assignment. Additional requirements:
Code must compile/run on your VM. You will demo this to the TA.
You must pack the packet in a structure. If you are using python, use the struct module.
Pay extra attention to byte-order encoding before sending the packet. Big-endianness is the dominant ordering in today\u0026rsquo;s network protocols.
Sample Output #Server side
Received connection from (IP, PORT): ('127.0.0.1', 53888) Received Data: version: 17 message_type: 1 length: 1280 VERSION ACCEPTED Received Data: version: 17 message_type: 2 length: 1792 VERSION ACCEPTED EXECUTING SUPPORTED COMMAND: LIGHTON Returning SUCCESS Received connection from (IP, PORT): ('127.0.0.1', 53890) Received Data: version: 17 message_type: 1 length: 1280 VERSION ACCEPTED Received Data: version: 17 message_type: 2 length: 1792 VERSION ACCEPTED EXECUTING SUPPORTED COMMAND: LIGHTON Returning SUCCESS Client Side
Run 1
Received Data: version: 17 type: 1 length: 1280 VERSION ACCEPTED Received Message Hello Sending command Received Data: version: 17 type: 2 length: 1792 VERSION ACCEPTED Received Message SUCCESS Command Successful Closing socket Run 2
Sending HELLO Packet Received Data: version: 17 type: 1 length: 1280 VERSION ACCEPTED Received Message Hello Sending command Received Data: version: 17 type: 2 length: 1792 VERSION ACCEPTED Received Message SUCCESS Command Successful Closing socket `}),e.add({id:4,href:"/docs/",title:"Docs",description:"Docs Doks.",content:""}),e.add({id:5,href:"/docs/prologue/pa-detect-person/",title:"Program 3 - Detect a Person",description:`Objectives
The objective of this assignment is to design and implement a client-server system using Raspberry Pi devices. The server will control an LED, while the client will sense motion using a Passive Infrared Sensor (PIR) and communicate with the server to blink the LED. The assignment includes establishing a three-way handshake, sending blink duration and count information, acknowledging the data, and responding to motion detection by blinking the LED.`,content:` Objectives
The objective of this assignment is to design and implement a client-server system using Raspberry Pi devices. The server will control an LED, while the client will sense motion using a Passive Infrared Sensor (PIR) and communicate with the server to blink the LED. The assignment includes establishing a three-way handshake, sending blink duration and count information, acknowledging the data, and responding to motion detection by blinking the LED. The client and server communications MUST use UDP (SOCK_DGRAM) and NOT TCP.
The objectives are:
\u0026ndash; Learn about physical computing
\u0026ndash; Learn about protocol development
Server Specifications
The server (we name it lightserver) takes two arguments:
\$ lightserver -p \u0026lt;PORT\u0026gt; -s \u0026lt;LOG FILE LOCATION\u0026gt; 1.PORT - The port server listens on.
2.Log File Location - log file location
Server\u0026rsquo;s Functional requirements
The server must open a UDP socket on the specified port number The server should gracefully process incorrect port number and exit with a non-zero error code The server runs indefinitely - it does not exit. The server accepts connections from multiple clients (bonus points) server works with any client developed by other teams (bonus points) Client Specifications
The client (we name it lightclient) takes three arguments: \$ lightclient -s \u0026lt;SERVER-IP\u0026gt; -p \u0026lt;PORT\u0026gt; -l LOGFILE The client takes three arguments:
1.Server IP - The IP address of the lightserver.
2.PORT - The port the server listens on.
2.Log file location - Where you will keep a record of packets you received.
For example: \$ lightclient -s 192.168.2.1 -p 6543 -l LOGFILE Packet Specification
The payload of each UDP packet sent by server and client MUST start with the following 12-byte header. All fields are in network order (most significant bit first):
0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Sequence Number | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Acknowledgment Number | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Not Used |A|S|F| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ Where:
Sequence Number (32 bits): If SYN is present (the S flag is set) the sequence number is the initial sequence number (randomly choosen).
Acknowledgement Number (32 bits): If the ACK bit is set, this field contains the value of the next sequence number the sender of the segment is expecting to receive. Once a connection is established this is always sent.
The acknowledgement number is given in the unit of bytes (how many bytes you have sent)
Not Used (29 bits): Must be zero.
A (ACK, 1 bit): Indicates that there the value of Acknowledgment Number field is valid
S (SYN, 1 bit): Synchronize sequence numbers
F (FIN, 1 bit): Finish, No more data from sender
This is the protocol you will implement
The client opens a UDP socket and initiate 3-way handshake to the specified hostname/ip and port. Essentially, the client and server will exchange three packets with the following flags set: (1) SYN (2) SYN|ACK (3)ACK. At the end of the handshake, they will have learned each other\u0026rsquo;s sequence number.
The client then sends the duration and number of blinks as a payload.
The server acknowledges the duration and the number of blinks.
The client senses motion using the PIR.
When motion is detected, the client logs it, and sends a message with the following string as the payload :MotionDetected
The server parses it, logs :MotionDetected to its log, and drives the LED for the pre-determined amount of times.
Client sends a packet with the FIN bit set. The server logs \u0026ldquo;:Interaction with completed. This finishes the interaction.
Timestamp format is \u0026ldquo;YYYY-MM-DD-HH-MM-SS\u0026rdquo;.
Hardware Components #Raspberry Pi Passive Infrared Sensor (PIR) LED Resistor Jumper wires Breadboard Server Setup #The server Raspberry Pi should be programmed to drive the LED. It should be capable of receiving data from the client and blinking the LED accordingly. Client Setup #The client Raspberry Pi should be programmed to interface with the PIR sensor. It should be able to establish a connection with the server. The client should continuously sense motion using the PIR sensor. You may test both server and client on the same board.
Submission:
Submit your code, packet capture in PCAP format, and your logs as a ZIP file. Additional requirements:
Code must compile/run on the PIs.
For each packet received, log both at server and receiver in the following format:
\u0026quot;RECV\u0026quot; \u0026lt;Sequence Number\u0026gt; \u0026lt;Acknowledgement Number\u0026gt; [\u0026quot;ACK\u0026quot;] [\u0026quot;SYN\u0026quot;] [\u0026quot;FIN\u0026quot;] \u0026quot;SEND\u0026quot; \u0026lt;Sequence Number\u0026gt; \u0026lt;Acknowledgement Number\u0026gt; [\u0026quot;ACK\u0026quot;] [\u0026quot;SYN\u0026quot;] [\u0026quot;FIN\u0026quot;] Hints #def create_packet(**kwargs):
data = struct.pack('!I', s_n) #pack the version .... data += struct.pack(\u0026quot;!c\u0026quot;, ack) #pack the ACK data += struct.pack(\u0026quot;!c\u0026quot;, syn) #pack the SYN data += struct.pack(\u0026quot;!c\u0026quot;, fin) #pack the FIN .... return data send_data = create_packet(sequence_number=100, ack_number=0, ack = 'Y', syn = 'N', fin = 'N', payload=data) Rubric #Protocol design points 1-7 - 10 points each. Successful reading from PIR - 10 points. Successful LED blinking - 10 points. Server can handle multiple clients - 10 points (bonus) Works with other teams\u0026rsquo; implementation - 10 points (bonus) Do not collaborate on code but test with each other\u0026rsquo;s code If your code works with another team\u0026rsquo;s code, you both get 10 points `}),search.addEventListener("input",t,!0);function t(){const s=5;var n=this.value,o=e.search(n,{limit:s,enrich:!0});const t=new Map;for(const e of o.flatMap(e=>e.result)){if(t.has(e.doc.href))continue;t.set(e.doc.href,e.doc)}if(suggestions.innerHTML="",suggestions.classList.remove("d-none"),t.size===0&&n){const e=document.createElement("div");e.innerHTML=`No results for "<strong>${n}</strong>"`,e.classList.add("suggestion__no-results"),suggestions.appendChild(e);return}for(const[r,a]of t){const n=document.createElement("div");suggestions.appendChild(n);const e=document.createElement("a");e.href=r,n.appendChild(e);const o=document.createElement("span");o.textContent=a.title,o.classList.add("suggestion__title"),e.appendChild(o);const i=document.createElement("span");if(i.textContent=a.description,i.classList.add("suggestion__description"),e.appendChild(i),suggestions.appendChild(n),suggestions.childElementCount==s)break}}})()